import random, math

def calculate_conflicts(state):
    n = len(state)
    conflicts = 0
    for i in range(n):
        for j in range(i + 1, n):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def random_neighbor(state):
    n = len(state)
    neighbor = state[:]
    col = random.randint(0, n - 1)
    row = random.randint(0, n - 1)
    neighbor[col] = row
    return neighbor

def simulated_annealing(n, initial_temp=100, cooling_rate=0.99, max_iterations=10000):
    current_state = [random.randint(0, n - 1) for _ in range(n)]
    current_cost = calculate_conflicts(current_state)
    T = initial_temp

    for step in range(max_iterations):
        if current_cost == 0:
            print(f"✅ Solution found in {step} iterations!")
            return current_state

        neighbor = random_neighbor(current_state)
        neighbor_cost = calculate_conflicts(neighbor)
        delta = neighbor_cost - current_cost

        if delta < 0 or random.random() < math.exp(-delta / T):
            current_state = neighbor
            current_cost = neighbor_cost

        T *= cooling_rate
        if T < 1e-5:
            break

    print("❌ No perfect solution found.")
    return current_state

def print_board(state):
    if state is None:
        print("No solution.")
        return
    n = len(state)
    for row in range(n):
        line = ""
        for col in range(n):
            line += "Q " if state[col] == row else ". "
        print(line)
    print()

n = 8
solution = simulated_annealing(n)
print_board(solution)
